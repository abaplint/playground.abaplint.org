"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkabaplint_playground"] = self["webpackChunkabaplint_playground"] || []).push([["vendors-node_modules_monaco-editor_esm_vs_editor_common_services_languageService_js"],{

/***/ "./node_modules/monaco-editor/esm/vs/base/common/equals.js":
/*!*****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/equals.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   equalsIfDefined: () => (/* binding */ equalsIfDefined),\n/* harmony export */   itemEquals: () => (/* binding */ itemEquals),\n/* harmony export */   itemsEquals: () => (/* binding */ itemsEquals),\n/* harmony export */   strictEquals: () => (/* binding */ strictEquals),\n/* harmony export */   structuralEquals: () => (/* binding */ structuralEquals)\n/* harmony export */ });\n/* harmony import */ var _arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrays.js */ \"./node_modules/monaco-editor/esm/vs/base/common/arrays.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Compares two items for equality using strict equality.\n*/\nconst strictEquals = (a, b) => a === b;\n/**\n * Checks if the items of two arrays are equal.\n * By default, strict equality is used to compare elements, but a custom equality comparer can be provided.\n */\nfunction itemsEquals(itemEquals = strictEquals) {\n    return (a, b) => _arrays_js__WEBPACK_IMPORTED_MODULE_0__.equals(a, b, itemEquals);\n}\n/**\n * Uses `item.equals(other)` to determine equality.\n */\nfunction itemEquals() {\n    return (a, b) => a.equals(b);\n}\nfunction equalsIfDefined(equalsOrV1, v2, equals) {\n    if (equals !== undefined) {\n        const v1 = equalsOrV1;\n        if (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {\n            return v2 === v1;\n        }\n        return equals(v1, v2);\n    }\n    else {\n        const equals = equalsOrV1;\n        return (v1, v2) => {\n            if (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {\n                return v2 === v1;\n            }\n            return equals(v1, v2);\n        };\n    }\n}\n/**\n * Drills into arrays (items ordered) and objects (keys unordered) and uses strict equality on everything else.\n*/\nfunction structuralEquals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0; i < a.length; i++) {\n            if (!structuralEquals(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (a && typeof a === 'object' && b && typeof b === 'object') {\n        if (Object.getPrototypeOf(a) === Object.prototype && Object.getPrototypeOf(b) === Object.prototype) {\n            const aObj = a;\n            const bObj = b;\n            const keysA = Object.keys(aObj);\n            const keysB = Object.keys(bObj);\n            const keysBSet = new Set(keysB);\n            if (keysA.length !== keysB.length) {\n                return false;\n            }\n            for (const key of keysA) {\n                if (!keysBSet.has(key)) {\n                    return false;\n                }\n                if (!structuralEquals(aObj[key], bObj[key])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    return false;\n}\nconst objIds = new WeakMap();\n\n\n//# sourceURL=webpack://abaplint-playground/./node_modules/monaco-editor/esm/vs/base/common/equals.js?\n}");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/observable.js":
/*!*********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/observable.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ObservablePromise: () => (/* reexport safe */ _observableInternal_promise_js__WEBPACK_IMPORTED_MODULE_4__.ObservablePromise),\n/* harmony export */   PromiseResult: () => (/* reexport safe */ _observableInternal_promise_js__WEBPACK_IMPORTED_MODULE_4__.PromiseResult),\n/* harmony export */   autorun: () => (/* reexport safe */ _observableInternal_autorun_js__WEBPACK_IMPORTED_MODULE_2__.autorun),\n/* harmony export */   autorunHandleChanges: () => (/* reexport safe */ _observableInternal_autorun_js__WEBPACK_IMPORTED_MODULE_2__.autorunHandleChanges),\n/* harmony export */   autorunOpts: () => (/* reexport safe */ _observableInternal_autorun_js__WEBPACK_IMPORTED_MODULE_2__.autorunOpts),\n/* harmony export */   autorunWithStore: () => (/* reexport safe */ _observableInternal_autorun_js__WEBPACK_IMPORTED_MODULE_2__.autorunWithStore),\n/* harmony export */   autorunWithStoreHandleChanges: () => (/* reexport safe */ _observableInternal_autorun_js__WEBPACK_IMPORTED_MODULE_2__.autorunWithStoreHandleChanges),\n/* harmony export */   constObservable: () => (/* reexport safe */ _observableInternal_utils_js__WEBPACK_IMPORTED_MODULE_3__.constObservable),\n/* harmony export */   derived: () => (/* reexport safe */ _observableInternal_derived_js__WEBPACK_IMPORTED_MODULE_1__.derived),\n/* harmony export */   derivedHandleChanges: () => (/* reexport safe */ _observableInternal_derived_js__WEBPACK_IMPORTED_MODULE_1__.derivedHandleChanges),\n/* harmony export */   derivedObservableWithCache: () => (/* reexport safe */ _observableInternal_utils_js__WEBPACK_IMPORTED_MODULE_3__.derivedObservableWithCache),\n/* harmony export */   derivedObservableWithWritableCache: () => (/* reexport safe */ _observableInternal_utils_js__WEBPACK_IMPORTED_MODULE_3__.derivedObservableWithWritableCache),\n/* harmony export */   derivedOpts: () => (/* reexport safe */ _observableInternal_derived_js__WEBPACK_IMPORTED_MODULE_1__.derivedOpts),\n/* harmony export */   derivedWithStore: () => (/* reexport safe */ _observableInternal_derived_js__WEBPACK_IMPORTED_MODULE_1__.derivedWithStore),\n/* harmony export */   disposableObservableValue: () => (/* reexport safe */ _observableInternal_base_js__WEBPACK_IMPORTED_MODULE_0__.disposableObservableValue),\n/* harmony export */   keepObserved: () => (/* reexport safe */ _observableInternal_utils_js__WEBPACK_IMPORTED_MODULE_3__.keepObserved),\n/* harmony export */   observableFromEvent: () => (/* reexport safe */ _observableInternal_utils_js__WEBPACK_IMPORTED_MODULE_3__.observableFromEvent),\n/* harmony export */   observableSignal: () => (/* reexport safe */ _observableInternal_utils_js__WEBPACK_IMPORTED_MODULE_3__.observableSignal),\n/* harmony export */   observableSignalFromEvent: () => (/* reexport safe */ _observableInternal_utils_js__WEBPACK_IMPORTED_MODULE_3__.observableSignalFromEvent),\n/* harmony export */   observableValue: () => (/* reexport safe */ _observableInternal_base_js__WEBPACK_IMPORTED_MODULE_0__.observableValue),\n/* harmony export */   observableValueOpts: () => (/* reexport safe */ _observableInternal_api_js__WEBPACK_IMPORTED_MODULE_5__.observableValueOpts),\n/* harmony export */   recomputeInitiallyAndOnChange: () => (/* reexport safe */ _observableInternal_utils_js__WEBPACK_IMPORTED_MODULE_3__.recomputeInitiallyAndOnChange),\n/* harmony export */   subtransaction: () => (/* reexport safe */ _observableInternal_base_js__WEBPACK_IMPORTED_MODULE_0__.subtransaction),\n/* harmony export */   transaction: () => (/* reexport safe */ _observableInternal_base_js__WEBPACK_IMPORTED_MODULE_0__.transaction),\n/* harmony export */   waitForState: () => (/* reexport safe */ _observableInternal_promise_js__WEBPACK_IMPORTED_MODULE_4__.waitForState)\n/* harmony export */ });\n/* harmony import */ var _observableInternal_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./observableInternal/base.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js\");\n/* harmony import */ var _observableInternal_derived_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./observableInternal/derived.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/derived.js\");\n/* harmony import */ var _observableInternal_autorun_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./observableInternal/autorun.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/autorun.js\");\n/* harmony import */ var _observableInternal_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./observableInternal/utils.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils.js\");\n/* harmony import */ var _observableInternal_promise_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./observableInternal/promise.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/promise.js\");\n/* harmony import */ var _observableInternal_api_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./observableInternal/api.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/api.js\");\n/* harmony import */ var _observableInternal_logging_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./observableInternal/logging.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n// Remove \"//\" in the next line to enable logging\nconst enableLogging = false;\nif (enableLogging) {\n    (0,_observableInternal_logging_js__WEBPACK_IMPORTED_MODULE_6__.setLogger)(new _observableInternal_logging_js__WEBPACK_IMPORTED_MODULE_6__.ConsoleObservableLogger());\n}\n\n\n//# sourceURL=webpack://abaplint-playground/./node_modules/monaco-editor/esm/vs/base/common/observable.js?\n}");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/api.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/observableInternal/api.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   observableValueOpts: () => (/* binding */ observableValueOpts)\n/* harmony export */ });\n/* harmony import */ var _equals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../equals.js */ \"./node_modules/monaco-editor/esm/vs/base/common/equals.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js\");\n/* harmony import */ var _debugName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debugName.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js\");\n/* harmony import */ var _lazyObservableValue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lazyObservableValue.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/lazyObservableValue.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\nfunction observableValueOpts(options, initialValue) {\n    if (options.lazy) {\n        return new _lazyObservableValue_js__WEBPACK_IMPORTED_MODULE_3__.LazyObservableValue(new _debugName_js__WEBPACK_IMPORTED_MODULE_2__.DebugNameData(options.owner, options.debugName, undefined), initialValue, options.equalsFn ?? _equals_js__WEBPACK_IMPORTED_MODULE_0__.strictEquals);\n    }\n    return new _base_js__WEBPACK_IMPORTED_MODULE_1__.ObservableValue(new _debugName_js__WEBPACK_IMPORTED_MODULE_2__.DebugNameData(options.owner, options.debugName, undefined), initialValue, options.equalsFn ?? _equals_js__WEBPACK_IMPORTED_MODULE_0__.strictEquals);\n}\n\n\n//# sourceURL=webpack://abaplint-playground/./node_modules/monaco-editor/esm/vs/base/common/observableInternal/api.js?\n}");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/autorun.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/observableInternal/autorun.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutorunObserver: () => (/* binding */ AutorunObserver),\n/* harmony export */   autorun: () => (/* binding */ autorun),\n/* harmony export */   autorunHandleChanges: () => (/* binding */ autorunHandleChanges),\n/* harmony export */   autorunOpts: () => (/* binding */ autorunOpts),\n/* harmony export */   autorunWithStore: () => (/* binding */ autorunWithStore),\n/* harmony export */   autorunWithStoreHandleChanges: () => (/* binding */ autorunWithStoreHandleChanges)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../assert.js */ \"./node_modules/monaco-editor/esm/vs/base/common/assert.js\");\n/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lifecycle.js */ \"./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js\");\n/* harmony import */ var _debugName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debugName.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js\");\n/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./logging.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nfunction autorun(fn) {\n    return new AutorunObserver(new _debugName_js__WEBPACK_IMPORTED_MODULE_2__.DebugNameData(undefined, undefined, fn), fn, undefined, undefined);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nfunction autorunOpts(options, fn) {\n    return new AutorunObserver(new _debugName_js__WEBPACK_IMPORTED_MODULE_2__.DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn), fn, undefined, undefined);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The run function is given the last change summary.\n * The change summary is discarded after the run function was called.\n *\n * @see autorun\n */\nfunction autorunHandleChanges(options, fn) {\n    return new AutorunObserver(new _debugName_js__WEBPACK_IMPORTED_MODULE_2__.DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn), fn, options.createEmptyChangeSummary, options.handleChange);\n}\n/**\n * @see autorunHandleChanges (but with a disposable store that is cleared before the next run or on dispose)\n */\nfunction autorunWithStoreHandleChanges(options, fn) {\n    const store = new _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.DisposableStore();\n    const disposable = autorunHandleChanges({\n        owner: options.owner,\n        debugName: options.debugName,\n        debugReferenceFn: options.debugReferenceFn ?? fn,\n        createEmptyChangeSummary: options.createEmptyChangeSummary,\n        handleChange: options.handleChange,\n    }, (reader, changeSummary) => {\n        store.clear();\n        fn(reader, changeSummary, store);\n    });\n    return (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => {\n        disposable.dispose();\n        store.dispose();\n    });\n}\n/**\n * @see autorun (but with a disposable store that is cleared before the next run or on dispose)\n */\nfunction autorunWithStore(fn) {\n    const store = new _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.DisposableStore();\n    const disposable = autorunOpts({\n        owner: undefined,\n        debugName: undefined,\n        debugReferenceFn: fn,\n    }, reader => {\n        store.clear();\n        fn(reader, store);\n    });\n    return (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => {\n        disposable.dispose();\n        store.dispose();\n    });\n}\nclass AutorunObserver {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? '(anonymous)';\n    }\n    constructor(_debugNameData, _runFn, createChangeSummary, _handleChange) {\n        this._debugNameData = _debugNameData;\n        this._runFn = _runFn;\n        this.createChangeSummary = createChangeSummary;\n        this._handleChange = _handleChange;\n        this.state = 2 /* AutorunState.stale */;\n        this.updateCount = 0;\n        this.disposed = false;\n        this.dependencies = new Set();\n        this.dependenciesToBeRemoved = new Set();\n        this.changeSummary = this.createChangeSummary?.();\n        (0,_logging_js__WEBPACK_IMPORTED_MODULE_3__.getLogger)()?.handleAutorunCreated(this);\n        this._runIfNeeded();\n        (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.trackDisposable)(this);\n    }\n    dispose() {\n        this.disposed = true;\n        for (const o of this.dependencies) {\n            o.removeObserver(this);\n        }\n        this.dependencies.clear();\n        (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.markAsDisposed)(this);\n    }\n    _runIfNeeded() {\n        if (this.state === 3 /* AutorunState.upToDate */) {\n            return;\n        }\n        const emptySet = this.dependenciesToBeRemoved;\n        this.dependenciesToBeRemoved = this.dependencies;\n        this.dependencies = emptySet;\n        this.state = 3 /* AutorunState.upToDate */;\n        const isDisposed = this.disposed;\n        try {\n            if (!isDisposed) {\n                (0,_logging_js__WEBPACK_IMPORTED_MODULE_3__.getLogger)()?.handleAutorunTriggered(this);\n                const changeSummary = this.changeSummary;\n                this.changeSummary = this.createChangeSummary?.();\n                this._runFn(this, changeSummary);\n            }\n        }\n        finally {\n            if (!isDisposed) {\n                (0,_logging_js__WEBPACK_IMPORTED_MODULE_3__.getLogger)()?.handleAutorunFinished(this);\n            }\n            // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n            // Thus, we only unsubscribe from observables that are definitely not read anymore.\n            for (const o of this.dependenciesToBeRemoved) {\n                o.removeObserver(this);\n            }\n            this.dependenciesToBeRemoved.clear();\n        }\n    }\n    toString() {\n        return `Autorun<${this.debugName}>`;\n    }\n    // IObserver implementation\n    beginUpdate() {\n        if (this.state === 3 /* AutorunState.upToDate */) {\n            this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n        }\n        this.updateCount++;\n    }\n    endUpdate() {\n        if (this.updateCount === 1) {\n            do {\n                if (this.state === 1 /* AutorunState.dependenciesMightHaveChanged */) {\n                    this.state = 3 /* AutorunState.upToDate */;\n                    for (const d of this.dependencies) {\n                        d.reportChanges();\n                        if (this.state === 2 /* AutorunState.stale */) {\n                            // The other dependencies will refresh on demand\n                            break;\n                        }\n                    }\n                }\n                this._runIfNeeded();\n            } while (this.state !== 3 /* AutorunState.upToDate */);\n        }\n        this.updateCount--;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertFn)(() => this.updateCount >= 0);\n    }\n    handlePossibleChange(observable) {\n        if (this.state === 3 /* AutorunState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n        }\n    }\n    handleChange(observable, change) {\n        if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            const shouldReact = this._handleChange ? this._handleChange({\n                changedObservable: observable,\n                change,\n                didChange: (o) => o === observable,\n            }, this.changeSummary) : true;\n            if (shouldReact) {\n                this.state = 2 /* AutorunState.stale */;\n            }\n        }\n    }\n    // IReader implementation\n    readObservable(observable) {\n        // In case the run action disposes the autorun\n        if (this.disposed) {\n            return observable.get();\n        }\n        observable.addObserver(this);\n        const value = observable.get();\n        this.dependencies.add(observable);\n        this.dependenciesToBeRemoved.delete(observable);\n        return value;\n    }\n}\n(function (autorun) {\n    autorun.Observer = AutorunObserver;\n})(autorun || (autorun = {}));\n\n\n//# sourceURL=webpack://abaplint-playground/./node_modules/monaco-editor/esm/vs/base/common/observableInternal/autorun.js?\n}");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseObservable: () => (/* binding */ BaseObservable),\n/* harmony export */   ConvenientObservable: () => (/* binding */ ConvenientObservable),\n/* harmony export */   DisposableObservableValue: () => (/* binding */ DisposableObservableValue),\n/* harmony export */   ObservableValue: () => (/* binding */ ObservableValue),\n/* harmony export */   TransactionImpl: () => (/* binding */ TransactionImpl),\n/* harmony export */   _setDerivedOpts: () => (/* binding */ _setDerivedOpts),\n/* harmony export */   _setKeepObserved: () => (/* binding */ _setKeepObserved),\n/* harmony export */   _setRecomputeInitiallyAndOnChange: () => (/* binding */ _setRecomputeInitiallyAndOnChange),\n/* harmony export */   asyncTransaction: () => (/* binding */ asyncTransaction),\n/* harmony export */   disposableObservableValue: () => (/* binding */ disposableObservableValue),\n/* harmony export */   globalTransaction: () => (/* binding */ globalTransaction),\n/* harmony export */   observableValue: () => (/* binding */ observableValue),\n/* harmony export */   subtransaction: () => (/* binding */ subtransaction),\n/* harmony export */   transaction: () => (/* binding */ transaction)\n/* harmony export */ });\n/* harmony import */ var _equals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../equals.js */ \"./node_modules/monaco-editor/esm/vs/base/common/equals.js\");\n/* harmony import */ var _debugName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./debugName.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js\");\n/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logging.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\nlet _recomputeInitiallyAndOnChange;\nfunction _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange) {\n    _recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\nlet _keepObserved;\nfunction _setKeepObserved(keepObserved) {\n    _keepObserved = keepObserved;\n}\nlet _derived;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nfunction _setDerivedOpts(derived) {\n    _derived = derived;\n}\nclass ConvenientObservable {\n    get TChange() { return null; }\n    reportChanges() {\n        this.get();\n    }\n    /** @sealed */\n    read(reader) {\n        if (reader) {\n            return reader.readObservable(this);\n        }\n        else {\n            return this.get();\n        }\n    }\n    map(fnOrOwner, fnOrUndefined) {\n        const owner = fnOrUndefined === undefined ? undefined : fnOrOwner;\n        const fn = fnOrUndefined === undefined ? fnOrOwner : fnOrUndefined;\n        return _derived({\n            owner,\n            debugName: () => {\n                const name = (0,_debugName_js__WEBPACK_IMPORTED_MODULE_1__.getFunctionName)(fn);\n                if (name !== undefined) {\n                    return name;\n                }\n                // regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):\n                const regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n                const match = regexp.exec(fn.toString());\n                if (match) {\n                    return `${this.debugName}.${match[2]}`;\n                }\n                if (!owner) {\n                    return `${this.debugName} (mapped)`;\n                }\n                return undefined;\n            },\n            debugReferenceFn: fn,\n        }, (reader) => fn(this.read(reader), reader));\n    }\n    /**\n     * @sealed\n     * Converts an observable of an observable value into a direct observable of the value.\n    */\n    flatten() {\n        return _derived({\n            owner: undefined,\n            debugName: () => `${this.debugName} (flattened)`,\n        }, (reader) => this.read(reader).read(reader));\n    }\n    recomputeInitiallyAndOnChange(store, handleValue) {\n        store.add(_recomputeInitiallyAndOnChange(this, handleValue));\n        return this;\n    }\n    /**\n     * Ensures that this observable is observed. This keeps the cache alive.\n     * However, in case of deriveds, it does not force eager evaluation (only when the value is read/get).\n     * Use `recomputeInitiallyAndOnChange` for eager evaluation.\n     */\n    keepObserved(store) {\n        store.add(_keepObserved(this));\n        return this;\n    }\n}\nclass BaseObservable extends ConvenientObservable {\n    constructor() {\n        super(...arguments);\n        this.observers = new Set();\n    }\n    addObserver(observer) {\n        const len = this.observers.size;\n        this.observers.add(observer);\n        if (len === 0) {\n            this.onFirstObserverAdded();\n        }\n    }\n    removeObserver(observer) {\n        const deleted = this.observers.delete(observer);\n        if (deleted && this.observers.size === 0) {\n            this.onLastObserverRemoved();\n        }\n    }\n    onFirstObserverAdded() { }\n    onLastObserverRemoved() { }\n}\n/**\n * Starts a transaction in which many observables can be changed at once.\n * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.\n * Reaction run on demand or when the transaction ends.\n */\nfunction transaction(fn, getDebugName) {\n    const tx = new TransactionImpl(fn, getDebugName);\n    try {\n        fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\nlet _globalTransaction = undefined;\nfunction globalTransaction(fn) {\n    if (_globalTransaction) {\n        fn(_globalTransaction);\n    }\n    else {\n        const tx = new TransactionImpl(fn, undefined);\n        _globalTransaction = tx;\n        try {\n            fn(tx);\n        }\n        finally {\n            tx.finish(); // During finish, more actions might be added to the transaction.\n            // Which is why we only clear the global transaction after finish.\n            _globalTransaction = undefined;\n        }\n    }\n}\nasync function asyncTransaction(fn, getDebugName) {\n    const tx = new TransactionImpl(fn, getDebugName);\n    try {\n        await fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\n/**\n * Allows to chain transactions.\n */\nfunction subtransaction(tx, fn, getDebugName) {\n    if (!tx) {\n        transaction(fn, getDebugName);\n    }\n    else {\n        fn(tx);\n    }\n}\nclass TransactionImpl {\n    constructor(_fn, _getDebugName) {\n        this._fn = _fn;\n        this._getDebugName = _getDebugName;\n        this.updatingObservers = [];\n        (0,_logging_js__WEBPACK_IMPORTED_MODULE_2__.getLogger)()?.handleBeginTransaction(this);\n    }\n    getDebugName() {\n        if (this._getDebugName) {\n            return this._getDebugName();\n        }\n        return (0,_debugName_js__WEBPACK_IMPORTED_MODULE_1__.getFunctionName)(this._fn);\n    }\n    updateObserver(observer, observable) {\n        // When this gets called while finish is active, they will still get considered\n        this.updatingObservers.push({ observer, observable });\n        observer.beginUpdate(observable);\n    }\n    finish() {\n        const updatingObservers = this.updatingObservers;\n        for (let i = 0; i < updatingObservers.length; i++) {\n            const { observer, observable } = updatingObservers[i];\n            observer.endUpdate(observable);\n        }\n        // Prevent anyone from updating observers from now on.\n        this.updatingObservers = null;\n        (0,_logging_js__WEBPACK_IMPORTED_MODULE_2__.getLogger)()?.handleEndTransaction();\n    }\n}\nfunction observableValue(nameOrOwner, initialValue) {\n    let debugNameData;\n    if (typeof nameOrOwner === 'string') {\n        debugNameData = new _debugName_js__WEBPACK_IMPORTED_MODULE_1__.DebugNameData(undefined, nameOrOwner, undefined);\n    }\n    else {\n        debugNameData = new _debugName_js__WEBPACK_IMPORTED_MODULE_1__.DebugNameData(nameOrOwner, undefined, undefined);\n    }\n    return new ObservableValue(debugNameData, initialValue, _equals_js__WEBPACK_IMPORTED_MODULE_0__.strictEquals);\n}\nclass ObservableValue extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? 'ObservableValue';\n    }\n    constructor(_debugNameData, initialValue, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._equalityComparator = _equalityComparator;\n        this._value = initialValue;\n    }\n    get() {\n        return this._value;\n    }\n    set(value, tx, change) {\n        if (change === undefined && this._equalityComparator(this._value, value)) {\n            return;\n        }\n        let _tx;\n        if (!tx) {\n            tx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n        }\n        try {\n            const oldValue = this._value;\n            this._setValue(value);\n            (0,_logging_js__WEBPACK_IMPORTED_MODULE_2__.getLogger)()?.handleObservableChanged(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });\n            for (const observer of this.observers) {\n                tx.updateObserver(observer, this);\n                observer.handleChange(this, change);\n            }\n        }\n        finally {\n            if (_tx) {\n                _tx.finish();\n            }\n        }\n    }\n    toString() {\n        return `${this.debugName}: ${this._value}`;\n    }\n    _setValue(newValue) {\n        this._value = newValue;\n    }\n}\n/**\n * A disposable observable. When disposed, its value is also disposed.\n * When a new value is set, the previous value is disposed.\n */\nfunction disposableObservableValue(nameOrOwner, initialValue) {\n    let debugNameData;\n    if (typeof nameOrOwner === 'string') {\n        debugNameData = new _debugName_js__WEBPACK_IMPORTED_MODULE_1__.DebugNameData(undefined, nameOrOwner, undefined);\n    }\n    else {\n        debugNameData = new _debugName_js__WEBPACK_IMPORTED_MODULE_1__.DebugNameData(nameOrOwner, undefined, undefined);\n    }\n    return new DisposableObservableValue(debugNameData, initialValue, _equals_js__WEBPACK_IMPORTED_MODULE_0__.strictEquals);\n}\nclass DisposableObservableValue extends ObservableValue {\n    _setValue(newValue) {\n        if (this._value === newValue) {\n            return;\n        }\n        if (this._value) {\n            this._value.dispose();\n        }\n        this._value = newValue;\n    }\n    dispose() {\n        this._value?.dispose();\n    }\n}\n\n\n//# sourceURL=webpack://abaplint-playground/./node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js?\n}");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DebugNameData: () => (/* binding */ DebugNameData),\n/* harmony export */   getDebugName: () => (/* binding */ getDebugName),\n/* harmony export */   getFunctionName: () => (/* binding */ getFunctionName)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass DebugNameData {\n    constructor(owner, debugNameSource, referenceFn) {\n        this.owner = owner;\n        this.debugNameSource = debugNameSource;\n        this.referenceFn = referenceFn;\n    }\n    getDebugName(target) {\n        return getDebugName(target, this);\n    }\n}\nconst countPerName = new Map();\nconst cachedDebugName = new WeakMap();\nfunction getDebugName(target, data) {\n    const cached = cachedDebugName.get(target);\n    if (cached) {\n        return cached;\n    }\n    const dbgName = computeDebugName(target, data);\n    if (dbgName) {\n        let count = countPerName.get(dbgName) ?? 0;\n        count++;\n        countPerName.set(dbgName, count);\n        const result = count === 1 ? dbgName : `${dbgName}#${count}`;\n        cachedDebugName.set(target, result);\n        return result;\n    }\n    return undefined;\n}\nfunction computeDebugName(self, data) {\n    const cached = cachedDebugName.get(self);\n    if (cached) {\n        return cached;\n    }\n    const ownerStr = data.owner ? formatOwner(data.owner) + `.` : '';\n    let result;\n    const debugNameSource = data.debugNameSource;\n    if (debugNameSource !== undefined) {\n        if (typeof debugNameSource === 'function') {\n            result = debugNameSource();\n            if (result !== undefined) {\n                return ownerStr + result;\n            }\n        }\n        else {\n            return ownerStr + debugNameSource;\n        }\n    }\n    const referenceFn = data.referenceFn;\n    if (referenceFn !== undefined) {\n        result = getFunctionName(referenceFn);\n        if (result !== undefined) {\n            return ownerStr + result;\n        }\n    }\n    if (data.owner !== undefined) {\n        const key = findKey(data.owner, self);\n        if (key !== undefined) {\n            return ownerStr + key;\n        }\n    }\n    return undefined;\n}\nfunction findKey(obj, value) {\n    for (const key in obj) {\n        if (obj[key] === value) {\n            return key;\n        }\n    }\n    return undefined;\n}\nconst countPerClassName = new Map();\nconst ownerId = new WeakMap();\nfunction formatOwner(owner) {\n    const id = ownerId.get(owner);\n    if (id) {\n        return id;\n    }\n    const className = getClassName(owner);\n    let count = countPerClassName.get(className) ?? 0;\n    count++;\n    countPerClassName.set(className, count);\n    const result = count === 1 ? className : `${className}#${count}`;\n    ownerId.set(owner, result);\n    return result;\n}\nfunction getClassName(obj) {\n    const ctor = obj.constructor;\n    if (ctor) {\n        return ctor.name;\n    }\n    return 'Object';\n}\nfunction getFunctionName(fn) {\n    const fnSrc = fn.toString();\n    // Pattern: /** @description ... */\n    const regexp = /\\/\\*\\*\\s*@description\\s*([^*]*)\\*\\//;\n    const match = regexp.exec(fnSrc);\n    const result = match ? match[1] : undefined;\n    return result?.trim();\n}\n\n\n//# sourceURL=webpack://abaplint-playground/./node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js?\n}");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/derived.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/observableInternal/derived.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Derived: () => (/* binding */ Derived),\n/* harmony export */   DerivedWithSetter: () => (/* binding */ DerivedWithSetter),\n/* harmony export */   derived: () => (/* binding */ derived),\n/* harmony export */   derivedDisposable: () => (/* binding */ derivedDisposable),\n/* harmony export */   derivedHandleChanges: () => (/* binding */ derivedHandleChanges),\n/* harmony export */   derivedOpts: () => (/* binding */ derivedOpts),\n/* harmony export */   derivedWithSetter: () => (/* binding */ derivedWithSetter),\n/* harmony export */   derivedWithStore: () => (/* binding */ derivedWithStore)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../assert.js */ \"./node_modules/monaco-editor/esm/vs/base/common/assert.js\");\n/* harmony import */ var _equals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../equals.js */ \"./node_modules/monaco-editor/esm/vs/base/common/equals.js\");\n/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lifecycle.js */ \"./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js\");\n/* harmony import */ var _debugName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./debugName.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js\");\n/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./logging.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\nfunction derived(computeFnOrOwner, computeFn) {\n    if (computeFn !== undefined) {\n        return new Derived(new _debugName_js__WEBPACK_IMPORTED_MODULE_4__.DebugNameData(computeFnOrOwner, undefined, computeFn), computeFn, undefined, undefined, undefined, _equals_js__WEBPACK_IMPORTED_MODULE_1__.strictEquals);\n    }\n    return new Derived(new _debugName_js__WEBPACK_IMPORTED_MODULE_4__.DebugNameData(undefined, undefined, computeFnOrOwner), computeFnOrOwner, undefined, undefined, undefined, _equals_js__WEBPACK_IMPORTED_MODULE_1__.strictEquals);\n}\nfunction derivedWithSetter(owner, computeFn, setter) {\n    return new DerivedWithSetter(new _debugName_js__WEBPACK_IMPORTED_MODULE_4__.DebugNameData(owner, undefined, computeFn), computeFn, undefined, undefined, undefined, _equals_js__WEBPACK_IMPORTED_MODULE_1__.strictEquals, setter);\n}\nfunction derivedOpts(options, computeFn) {\n    return new Derived(new _debugName_js__WEBPACK_IMPORTED_MODULE_4__.DebugNameData(options.owner, options.debugName, options.debugReferenceFn), computeFn, undefined, undefined, options.onLastObserverRemoved, options.equalsFn ?? _equals_js__WEBPACK_IMPORTED_MODULE_1__.strictEquals);\n}\n(0,_base_js__WEBPACK_IMPORTED_MODULE_3__._setDerivedOpts)(derivedOpts);\n/**\n * Represents an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The compute function is given the last change summary.\n * The change summary is discarded after the compute function was called.\n *\n * @see derived\n */\nfunction derivedHandleChanges(options, computeFn) {\n    return new Derived(new _debugName_js__WEBPACK_IMPORTED_MODULE_4__.DebugNameData(options.owner, options.debugName, undefined), computeFn, options.createEmptyChangeSummary, options.handleChange, undefined, options.equalityComparer ?? _equals_js__WEBPACK_IMPORTED_MODULE_1__.strictEquals);\n}\nfunction derivedWithStore(computeFnOrOwner, computeFnOrUndefined) {\n    let computeFn;\n    let owner;\n    if (computeFnOrUndefined === undefined) {\n        computeFn = computeFnOrOwner;\n        owner = undefined;\n    }\n    else {\n        owner = computeFnOrOwner;\n        computeFn = computeFnOrUndefined;\n    }\n    const store = new _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStore();\n    return new Derived(new _debugName_js__WEBPACK_IMPORTED_MODULE_4__.DebugNameData(owner, undefined, computeFn), r => {\n        store.clear();\n        return computeFn(r, store);\n    }, undefined, undefined, () => store.dispose(), _equals_js__WEBPACK_IMPORTED_MODULE_1__.strictEquals);\n}\nfunction derivedDisposable(computeFnOrOwner, computeFnOrUndefined) {\n    let computeFn;\n    let owner;\n    if (computeFnOrUndefined === undefined) {\n        computeFn = computeFnOrOwner;\n        owner = undefined;\n    }\n    else {\n        owner = computeFnOrOwner;\n        computeFn = computeFnOrUndefined;\n    }\n    let store = undefined;\n    return new Derived(new _debugName_js__WEBPACK_IMPORTED_MODULE_4__.DebugNameData(owner, undefined, computeFn), r => {\n        if (!store) {\n            store = new _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStore();\n        }\n        else {\n            store.clear();\n        }\n        const result = computeFn(r);\n        if (result) {\n            store.add(result);\n        }\n        return result;\n    }, undefined, undefined, () => {\n        if (store) {\n            store.dispose();\n            store = undefined;\n        }\n    }, _equals_js__WEBPACK_IMPORTED_MODULE_1__.strictEquals);\n}\nclass Derived extends _base_js__WEBPACK_IMPORTED_MODULE_3__.BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? '(anonymous)';\n    }\n    constructor(_debugNameData, _computeFn, createChangeSummary, _handleChange, _handleLastObserverRemoved = undefined, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._computeFn = _computeFn;\n        this.createChangeSummary = createChangeSummary;\n        this._handleChange = _handleChange;\n        this._handleLastObserverRemoved = _handleLastObserverRemoved;\n        this._equalityComparator = _equalityComparator;\n        this.state = 0 /* DerivedState.initial */;\n        this.value = undefined;\n        this.updateCount = 0;\n        this.dependencies = new Set();\n        this.dependenciesToBeRemoved = new Set();\n        this.changeSummary = undefined;\n        this.changeSummary = this.createChangeSummary?.();\n        (0,_logging_js__WEBPACK_IMPORTED_MODULE_5__.getLogger)()?.handleDerivedCreated(this);\n    }\n    onLastObserverRemoved() {\n        /**\n         * We are not tracking changes anymore, thus we have to assume\n         * that our cache is invalid.\n         */\n        this.state = 0 /* DerivedState.initial */;\n        this.value = undefined;\n        for (const d of this.dependencies) {\n            d.removeObserver(this);\n        }\n        this.dependencies.clear();\n        this._handleLastObserverRemoved?.();\n    }\n    get() {\n        if (this.observers.size === 0) {\n            // Without observers, we don't know when to clean up stuff.\n            // Thus, we don't cache anything to prevent memory leaks.\n            const result = this._computeFn(this, this.createChangeSummary?.());\n            // Clear new dependencies\n            this.onLastObserverRemoved();\n            return result;\n        }\n        else {\n            do {\n                // We might not get a notification for a dependency that changed while it is updating,\n                // thus we also have to ask all our depedencies if they changed in this case.\n                if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n                    for (const d of this.dependencies) {\n                        /** might call {@link handleChange} indirectly, which could make us stale */\n                        d.reportChanges();\n                        if (this.state === 2 /* DerivedState.stale */) {\n                            // The other dependencies will refresh on demand, so early break\n                            break;\n                        }\n                    }\n                }\n                // We called report changes of all dependencies.\n                // If we are still not stale, we can assume to be up to date again.\n                if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n                    this.state = 3 /* DerivedState.upToDate */;\n                }\n                this._recomputeIfNeeded();\n                // In case recomputation changed one of our dependencies, we need to recompute again.\n            } while (this.state !== 3 /* DerivedState.upToDate */);\n            return this.value;\n        }\n    }\n    _recomputeIfNeeded() {\n        if (this.state === 3 /* DerivedState.upToDate */) {\n            return;\n        }\n        const emptySet = this.dependenciesToBeRemoved;\n        this.dependenciesToBeRemoved = this.dependencies;\n        this.dependencies = emptySet;\n        const hadValue = this.state !== 0 /* DerivedState.initial */;\n        const oldValue = this.value;\n        this.state = 3 /* DerivedState.upToDate */;\n        const changeSummary = this.changeSummary;\n        this.changeSummary = this.createChangeSummary?.();\n        try {\n            /** might call {@link handleChange} indirectly, which could invalidate us */\n            this.value = this._computeFn(this, changeSummary);\n        }\n        finally {\n            // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n            // Thus, we only unsubscribe from observables that are definitely not read anymore.\n            for (const o of this.dependenciesToBeRemoved) {\n                o.removeObserver(this);\n            }\n            this.dependenciesToBeRemoved.clear();\n        }\n        const didChange = hadValue && !(this._equalityComparator(oldValue, this.value));\n        (0,_logging_js__WEBPACK_IMPORTED_MODULE_5__.getLogger)()?.handleDerivedRecomputed(this, {\n            oldValue,\n            newValue: this.value,\n            change: undefined,\n            didChange,\n            hadValue,\n        });\n        if (didChange) {\n            for (const r of this.observers) {\n                r.handleChange(this, undefined);\n            }\n        }\n    }\n    toString() {\n        return `LazyDerived<${this.debugName}>`;\n    }\n    // IObserver Implementation\n    beginUpdate(_observable) {\n        this.updateCount++;\n        const propagateBeginUpdate = this.updateCount === 1;\n        if (this.state === 3 /* DerivedState.upToDate */) {\n            this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n            // If we propagate begin update, that will already signal a possible change.\n            if (!propagateBeginUpdate) {\n                for (const r of this.observers) {\n                    r.handlePossibleChange(this);\n                }\n            }\n        }\n        if (propagateBeginUpdate) {\n            for (const r of this.observers) {\n                r.beginUpdate(this); // This signals a possible change\n            }\n        }\n    }\n    endUpdate(_observable) {\n        this.updateCount--;\n        if (this.updateCount === 0) {\n            // End update could change the observer list.\n            const observers = [...this.observers];\n            for (const r of observers) {\n                r.endUpdate(this);\n            }\n        }\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertFn)(() => this.updateCount >= 0);\n    }\n    handlePossibleChange(observable) {\n        // In all other states, observers already know that we might have changed.\n        if (this.state === 3 /* DerivedState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n            for (const r of this.observers) {\n                r.handlePossibleChange(this);\n            }\n        }\n    }\n    handleChange(observable, change) {\n        if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            const shouldReact = this._handleChange ? this._handleChange({\n                changedObservable: observable,\n                change,\n                didChange: (o) => o === observable,\n            }, this.changeSummary) : true;\n            const wasUpToDate = this.state === 3 /* DerivedState.upToDate */;\n            if (shouldReact && (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */ || wasUpToDate)) {\n                this.state = 2 /* DerivedState.stale */;\n                if (wasUpToDate) {\n                    for (const r of this.observers) {\n                        r.handlePossibleChange(this);\n                    }\n                }\n            }\n        }\n    }\n    // IReader Implementation\n    readObservable(observable) {\n        // Subscribe before getting the value to enable caching\n        observable.addObserver(this);\n        /** This might call {@link handleChange} indirectly, which could invalidate us */\n        const value = observable.get();\n        // Which is why we only add the observable to the dependencies now.\n        this.dependencies.add(observable);\n        this.dependenciesToBeRemoved.delete(observable);\n        return value;\n    }\n    addObserver(observer) {\n        const shouldCallBeginUpdate = !this.observers.has(observer) && this.updateCount > 0;\n        super.addObserver(observer);\n        if (shouldCallBeginUpdate) {\n            observer.beginUpdate(this);\n        }\n    }\n    removeObserver(observer) {\n        const shouldCallEndUpdate = this.observers.has(observer) && this.updateCount > 0;\n        super.removeObserver(observer);\n        if (shouldCallEndUpdate) {\n            // Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n            observer.endUpdate(this);\n        }\n    }\n}\nclass DerivedWithSetter extends Derived {\n    constructor(debugNameData, computeFn, createChangeSummary, handleChange, handleLastObserverRemoved = undefined, equalityComparator, set) {\n        super(debugNameData, computeFn, createChangeSummary, handleChange, handleLastObserverRemoved, equalityComparator);\n        this.set = set;\n    }\n}\n\n\n//# sourceURL=webpack://abaplint-playground/./node_modules/monaco-editor/esm/vs/base/common/observableInternal/derived.js?\n}");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/lazyObservableValue.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/observableInternal/lazyObservableValue.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LazyObservableValue: () => (/* binding */ LazyObservableValue)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Holds off updating observers until the value is actually read.\n*/\nclass LazyObservableValue extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? 'LazyObservableValue';\n    }\n    constructor(_debugNameData, initialValue, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._equalityComparator = _equalityComparator;\n        this._isUpToDate = true;\n        this._deltas = [];\n        this._updateCounter = 0;\n        this._value = initialValue;\n    }\n    get() {\n        this._update();\n        return this._value;\n    }\n    _update() {\n        if (this._isUpToDate) {\n            return;\n        }\n        this._isUpToDate = true;\n        if (this._deltas.length > 0) {\n            for (const observer of this.observers) {\n                for (const change of this._deltas) {\n                    observer.handleChange(this, change);\n                }\n            }\n            this._deltas.length = 0;\n        }\n        else {\n            for (const observer of this.observers) {\n                observer.handleChange(this, undefined);\n            }\n        }\n    }\n    _beginUpdate() {\n        this._updateCounter++;\n        if (this._updateCounter === 1) {\n            for (const observer of this.observers) {\n                observer.beginUpdate(this);\n            }\n        }\n    }\n    _endUpdate() {\n        this._updateCounter--;\n        if (this._updateCounter === 0) {\n            this._update();\n            // End update could change the observer list.\n            const observers = [...this.observers];\n            for (const r of observers) {\n                r.endUpdate(this);\n            }\n        }\n    }\n    addObserver(observer) {\n        const shouldCallBeginUpdate = !this.observers.has(observer) && this._updateCounter > 0;\n        super.addObserver(observer);\n        if (shouldCallBeginUpdate) {\n            observer.beginUpdate(this);\n        }\n    }\n    removeObserver(observer) {\n        const shouldCallEndUpdate = this.observers.has(observer) && this._updateCounter > 0;\n        super.removeObserver(observer);\n        if (shouldCallEndUpdate) {\n            // Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n            observer.endUpdate(this);\n        }\n    }\n    set(value, tx, change) {\n        if (change === undefined && this._equalityComparator(this._value, value)) {\n            return;\n        }\n        let _tx;\n        if (!tx) {\n            tx = _tx = new _base_js__WEBPACK_IMPORTED_MODULE_0__.TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n        }\n        try {\n            this._isUpToDate = false;\n            this._setValue(value);\n            if (change !== undefined) {\n                this._deltas.push(change);\n            }\n            tx.updateObserver({\n                beginUpdate: () => this._beginUpdate(),\n                endUpdate: () => this._endUpdate(),\n                handleChange: (observable, change) => { },\n                handlePossibleChange: (observable) => { },\n            }, this);\n            if (this._updateCounter > 1) {\n                // We already started begin/end update, so we need to manually call handlePossibleChange\n                for (const observer of this.observers) {\n                    observer.handlePossibleChange(this);\n                }\n            }\n        }\n        finally {\n            if (_tx) {\n                _tx.finish();\n            }\n        }\n    }\n    toString() {\n        return `${this.debugName}: ${this._value}`;\n    }\n    _setValue(newValue) {\n        this._value = newValue;\n    }\n}\n\n\n//# sourceURL=webpack://abaplint-playground/./node_modules/monaco-editor/esm/vs/base/common/observableInternal/lazyObservableValue.js?\n}");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConsoleObservableLogger: () => (/* binding */ ConsoleObservableLogger),\n/* harmony export */   getLogger: () => (/* binding */ getLogger),\n/* harmony export */   setLogger: () => (/* binding */ setLogger)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nlet globalObservableLogger;\nfunction setLogger(logger) {\n    globalObservableLogger = logger;\n}\nfunction getLogger() {\n    return globalObservableLogger;\n}\nclass ConsoleObservableLogger {\n    constructor() {\n        this.indentation = 0;\n        this.changedObservablesSets = new WeakMap();\n    }\n    textToConsoleArgs(text) {\n        return consoleTextToArgs([\n            normalText(repeat('|  ', this.indentation)),\n            text,\n        ]);\n    }\n    formatInfo(info) {\n        if (!info.hadValue) {\n            return [\n                normalText(` `),\n                styled(formatValue(info.newValue, 60), {\n                    color: 'green',\n                }),\n                normalText(` (initial)`),\n            ];\n        }\n        return info.didChange\n            ? [\n                normalText(` `),\n                styled(formatValue(info.oldValue, 70), {\n                    color: 'red',\n                    strikeThrough: true,\n                }),\n                normalText(` `),\n                styled(formatValue(info.newValue, 60), {\n                    color: 'green',\n                }),\n            ]\n            : [normalText(` (unchanged)`)];\n    }\n    handleObservableChanged(observable, info) {\n        console.log(...this.textToConsoleArgs([\n            formatKind('observable value changed'),\n            styled(observable.debugName, { color: 'BlueViolet' }),\n            ...this.formatInfo(info),\n        ]));\n    }\n    formatChanges(changes) {\n        if (changes.size === 0) {\n            return undefined;\n        }\n        return styled(' (changed deps: ' +\n            [...changes].map((o) => o.debugName).join(', ') +\n            ')', { color: 'gray' });\n    }\n    handleDerivedCreated(derived) {\n        const existingHandleChange = derived.handleChange;\n        this.changedObservablesSets.set(derived, new Set());\n        derived.handleChange = (observable, change) => {\n            this.changedObservablesSets.get(derived).add(observable);\n            return existingHandleChange.apply(derived, [observable, change]);\n        };\n    }\n    handleDerivedRecomputed(derived, info) {\n        const changedObservables = this.changedObservablesSets.get(derived);\n        console.log(...this.textToConsoleArgs([\n            formatKind('derived recomputed'),\n            styled(derived.debugName, { color: 'BlueViolet' }),\n            ...this.formatInfo(info),\n            this.formatChanges(changedObservables),\n            { data: [{ fn: derived._debugNameData.referenceFn ?? derived._computeFn }] }\n        ]));\n        changedObservables.clear();\n    }\n    handleFromEventObservableTriggered(observable, info) {\n        console.log(...this.textToConsoleArgs([\n            formatKind('observable from event triggered'),\n            styled(observable.debugName, { color: 'BlueViolet' }),\n            ...this.formatInfo(info),\n            { data: [{ fn: observable._getValue }] }\n        ]));\n    }\n    handleAutorunCreated(autorun) {\n        const existingHandleChange = autorun.handleChange;\n        this.changedObservablesSets.set(autorun, new Set());\n        autorun.handleChange = (observable, change) => {\n            this.changedObservablesSets.get(autorun).add(observable);\n            return existingHandleChange.apply(autorun, [observable, change]);\n        };\n    }\n    handleAutorunTriggered(autorun) {\n        const changedObservables = this.changedObservablesSets.get(autorun);\n        console.log(...this.textToConsoleArgs([\n            formatKind('autorun'),\n            styled(autorun.debugName, { color: 'BlueViolet' }),\n            this.formatChanges(changedObservables),\n            { data: [{ fn: autorun._debugNameData.referenceFn ?? autorun._runFn }] }\n        ]));\n        changedObservables.clear();\n        this.indentation++;\n    }\n    handleAutorunFinished(autorun) {\n        this.indentation--;\n    }\n    handleBeginTransaction(transaction) {\n        let transactionName = transaction.getDebugName();\n        if (transactionName === undefined) {\n            transactionName = '';\n        }\n        console.log(...this.textToConsoleArgs([\n            formatKind('transaction'),\n            styled(transactionName, { color: 'BlueViolet' }),\n            { data: [{ fn: transaction._fn }] }\n        ]));\n        this.indentation++;\n    }\n    handleEndTransaction() {\n        this.indentation--;\n    }\n}\nfunction consoleTextToArgs(text) {\n    const styles = new Array();\n    const data = [];\n    let firstArg = '';\n    function process(t) {\n        if ('length' in t) {\n            for (const item of t) {\n                if (item) {\n                    process(item);\n                }\n            }\n        }\n        else if ('text' in t) {\n            firstArg += `%c${t.text}`;\n            styles.push(t.style);\n            if (t.data) {\n                data.push(...t.data);\n            }\n        }\n        else if ('data' in t) {\n            data.push(...t.data);\n        }\n    }\n    process(text);\n    const result = [firstArg, ...styles];\n    result.push(...data);\n    return result;\n}\nfunction normalText(text) {\n    return styled(text, { color: 'black' });\n}\nfunction formatKind(kind) {\n    return styled(padStr(`${kind}: `, 10), { color: 'black', bold: true });\n}\nfunction styled(text, options = {\n    color: 'black',\n}) {\n    function objToCss(styleObj) {\n        return Object.entries(styleObj).reduce((styleString, [propName, propValue]) => {\n            return `${styleString}${propName}:${propValue};`;\n        }, '');\n    }\n    const style = {\n        color: options.color,\n    };\n    if (options.strikeThrough) {\n        style['text-decoration'] = 'line-through';\n    }\n    if (options.bold) {\n        style['font-weight'] = 'bold';\n    }\n    return {\n        text,\n        style: objToCss(style),\n    };\n}\nfunction formatValue(value, availableLen) {\n    switch (typeof value) {\n        case 'number':\n            return '' + value;\n        case 'string':\n            if (value.length + 2 <= availableLen) {\n                return `\"${value}\"`;\n            }\n            return `\"${value.substr(0, availableLen - 7)}\"+...`;\n        case 'boolean':\n            return value ? 'true' : 'false';\n        case 'undefined':\n            return 'undefined';\n        case 'object':\n            if (value === null) {\n                return 'null';\n            }\n            if (Array.isArray(value)) {\n                return formatArray(value, availableLen);\n            }\n            return formatObject(value, availableLen);\n        case 'symbol':\n            return value.toString();\n        case 'function':\n            return `[[Function${value.name ? ' ' + value.name : ''}]]`;\n        default:\n            return '' + value;\n    }\n}\nfunction formatArray(value, availableLen) {\n    let result = '[ ';\n    let first = true;\n    for (const val of value) {\n        if (!first) {\n            result += ', ';\n        }\n        if (result.length - 5 > availableLen) {\n            result += '...';\n            break;\n        }\n        first = false;\n        result += `${formatValue(val, availableLen - result.length)}`;\n    }\n    result += ' ]';\n    return result;\n}\nfunction formatObject(value, availableLen) {\n    let result = '{ ';\n    let first = true;\n    for (const [key, val] of Object.entries(value)) {\n        if (!first) {\n            result += ', ';\n        }\n        if (result.length - 5 > availableLen) {\n            result += '...';\n            break;\n        }\n        first = false;\n        result += `${key}: ${formatValue(val, availableLen - result.length)}`;\n    }\n    result += ' }';\n    return result;\n}\nfunction repeat(str, count) {\n    let result = '';\n    for (let i = 1; i <= count; i++) {\n        result += str;\n    }\n    return result;\n}\nfunction padStr(str, length) {\n    while (str.length < length) {\n        str += ' ';\n    }\n    return str;\n}\n\n\n//# sourceURL=webpack://abaplint-playground/./node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging.js?\n}");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/promise.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/observableInternal/promise.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ObservablePromise: () => (/* binding */ ObservablePromise),\n/* harmony export */   PromiseResult: () => (/* binding */ PromiseResult),\n/* harmony export */   waitForState: () => (/* binding */ waitForState)\n/* harmony export */ });\n/* harmony import */ var _autorun_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./autorun.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/autorun.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors.js */ \"./node_modules/monaco-editor/esm/vs/base/common/errors.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n/**\n * A promise whose state is observable.\n */\nclass ObservablePromise {\n    static fromFn(fn) {\n        return new ObservablePromise(fn());\n    }\n    constructor(promise) {\n        this._value = (0,_base_js__WEBPACK_IMPORTED_MODULE_1__.observableValue)(this, undefined);\n        /**\n         * The current state of the promise.\n         * Is `undefined` if the promise didn't resolve yet.\n         */\n        this.promiseResult = this._value;\n        this.promise = promise.then(value => {\n            (0,_base_js__WEBPACK_IMPORTED_MODULE_1__.transaction)(tx => {\n                /** @description onPromiseResolved */\n                this._value.set(new PromiseResult(value, undefined), tx);\n            });\n            return value;\n        }, error => {\n            (0,_base_js__WEBPACK_IMPORTED_MODULE_1__.transaction)(tx => {\n                /** @description onPromiseRejected */\n                this._value.set(new PromiseResult(undefined, error), tx);\n            });\n            throw error;\n        });\n    }\n}\nclass PromiseResult {\n    constructor(\n    /**\n     * The value of the resolved promise.\n     * Undefined if the promise rejected.\n     */\n    data, \n    /**\n     * The error in case of a rejected promise.\n     * Undefined if the promise resolved.\n     */\n    error) {\n        this.data = data;\n        this.error = error;\n    }\n}\nfunction waitForState(observable, predicate, isError, cancellationToken) {\n    if (!predicate) {\n        predicate = state => state !== null && state !== undefined;\n    }\n    return new Promise((resolve, reject) => {\n        let isImmediateRun = true;\n        let shouldDispose = false;\n        const stateObs = observable.map(state => {\n            /** @description waitForState.state */\n            return {\n                isFinished: predicate(state),\n                error: isError ? isError(state) : false,\n                state\n            };\n        });\n        const d = (0,_autorun_js__WEBPACK_IMPORTED_MODULE_0__.autorun)(reader => {\n            /** @description waitForState */\n            const { isFinished, error, state } = stateObs.read(reader);\n            if (isFinished || error) {\n                if (isImmediateRun) {\n                    // The variable `d` is not initialized yet\n                    shouldDispose = true;\n                }\n                else {\n                    d.dispose();\n                }\n                if (error) {\n                    reject(error === true ? state : error);\n                }\n                else {\n                    resolve(state);\n                }\n            }\n        });\n        if (cancellationToken) {\n            const dc = cancellationToken.onCancellationRequested(() => {\n                d.dispose();\n                dc.dispose();\n                reject(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.CancellationError());\n            });\n            if (cancellationToken.isCancellationRequested) {\n                d.dispose();\n                dc.dispose();\n                reject(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.CancellationError());\n                return;\n            }\n        }\n        isImmediateRun = false;\n        if (shouldDispose) {\n            d.dispose();\n        }\n    });\n}\n\n\n//# sourceURL=webpack://abaplint-playground/./node_modules/monaco-editor/esm/vs/base/common/observableInternal/promise.js?\n}");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FromEventObservable: () => (/* binding */ FromEventObservable),\n/* harmony export */   KeepAliveObserver: () => (/* binding */ KeepAliveObserver),\n/* harmony export */   ValueWithChangeEventFromObservable: () => (/* binding */ ValueWithChangeEventFromObservable),\n/* harmony export */   constObservable: () => (/* binding */ constObservable),\n/* harmony export */   derivedConstOnceDefined: () => (/* binding */ derivedConstOnceDefined),\n/* harmony export */   derivedObservableWithCache: () => (/* binding */ derivedObservableWithCache),\n/* harmony export */   derivedObservableWithWritableCache: () => (/* binding */ derivedObservableWithWritableCache),\n/* harmony export */   keepObserved: () => (/* binding */ keepObserved),\n/* harmony export */   mapObservableArrayCached: () => (/* binding */ mapObservableArrayCached),\n/* harmony export */   observableFromEvent: () => (/* binding */ observableFromEvent),\n/* harmony export */   observableFromEventOpts: () => (/* binding */ observableFromEventOpts),\n/* harmony export */   observableFromValueWithChangeEvent: () => (/* binding */ observableFromValueWithChangeEvent),\n/* harmony export */   observableSignal: () => (/* binding */ observableSignal),\n/* harmony export */   observableSignalFromEvent: () => (/* binding */ observableSignalFromEvent),\n/* harmony export */   recomputeInitiallyAndOnChange: () => (/* binding */ recomputeInitiallyAndOnChange)\n/* harmony export */ });\n/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../event.js */ \"./node_modules/monaco-editor/esm/vs/base/common/event.js\");\n/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lifecycle.js */ \"./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js\");\n/* harmony import */ var _debugName_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./debugName.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js\");\n/* harmony import */ var _derived_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./derived.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/derived.js\");\n/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./logging.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging.js\");\n/* harmony import */ var _equals_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../equals.js */ \"./node_modules/monaco-editor/esm/vs/base/common/equals.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n/**\n * Represents an efficient observable whose value never changes.\n */\nfunction constObservable(value) {\n    return new ConstObservable(value);\n}\nclass ConstObservable extends _base_js__WEBPACK_IMPORTED_MODULE_2__.ConvenientObservable {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    get debugName() {\n        return this.toString();\n    }\n    get() {\n        return this.value;\n    }\n    addObserver(observer) {\n        // NO OP\n    }\n    removeObserver(observer) {\n        // NO OP\n    }\n    toString() {\n        return `Const: ${this.value}`;\n    }\n}\nfunction observableFromEvent(...args) {\n    let owner;\n    let event;\n    let getValue;\n    if (args.length === 3) {\n        [owner, event, getValue] = args;\n    }\n    else {\n        [event, getValue] = args;\n    }\n    return new FromEventObservable(new _debugName_js__WEBPACK_IMPORTED_MODULE_3__.DebugNameData(owner, undefined, getValue), event, getValue, () => FromEventObservable.globalTransaction, _equals_js__WEBPACK_IMPORTED_MODULE_6__.strictEquals);\n}\nfunction observableFromEventOpts(options, event, getValue) {\n    return new FromEventObservable(new _debugName_js__WEBPACK_IMPORTED_MODULE_3__.DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? getValue), event, getValue, () => FromEventObservable.globalTransaction, options.equalsFn ?? _equals_js__WEBPACK_IMPORTED_MODULE_6__.strictEquals);\n}\nclass FromEventObservable extends _base_js__WEBPACK_IMPORTED_MODULE_2__.BaseObservable {\n    constructor(_debugNameData, event, _getValue, _getTransaction, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this.event = event;\n        this._getValue = _getValue;\n        this._getTransaction = _getTransaction;\n        this._equalityComparator = _equalityComparator;\n        this.hasValue = false;\n        this.handleEvent = (args) => {\n            const newValue = this._getValue(args);\n            const oldValue = this.value;\n            const didChange = !this.hasValue || !(this._equalityComparator(oldValue, newValue));\n            let didRunTransaction = false;\n            if (didChange) {\n                this.value = newValue;\n                if (this.hasValue) {\n                    didRunTransaction = true;\n                    (0,_base_js__WEBPACK_IMPORTED_MODULE_2__.subtransaction)(this._getTransaction(), (tx) => {\n                        (0,_logging_js__WEBPACK_IMPORTED_MODULE_5__.getLogger)()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n                        for (const o of this.observers) {\n                            tx.updateObserver(o, this);\n                            o.handleChange(this, undefined);\n                        }\n                    }, () => {\n                        const name = this.getDebugName();\n                        return 'Event fired' + (name ? `: ${name}` : '');\n                    });\n                }\n                this.hasValue = true;\n            }\n            if (!didRunTransaction) {\n                (0,_logging_js__WEBPACK_IMPORTED_MODULE_5__.getLogger)()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n            }\n        };\n    }\n    getDebugName() {\n        return this._debugNameData.getDebugName(this);\n    }\n    get debugName() {\n        const name = this.getDebugName();\n        return 'From Event' + (name ? `: ${name}` : '');\n    }\n    onFirstObserverAdded() {\n        this.subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this.subscription.dispose();\n        this.subscription = undefined;\n        this.hasValue = false;\n        this.value = undefined;\n    }\n    get() {\n        if (this.subscription) {\n            if (!this.hasValue) {\n                this.handleEvent(undefined);\n            }\n            return this.value;\n        }\n        else {\n            // no cache, as there are no subscribers to keep it updated\n            const value = this._getValue(undefined);\n            return value;\n        }\n    }\n}\n(function (observableFromEvent) {\n    observableFromEvent.Observer = FromEventObservable;\n    function batchEventsGlobally(tx, fn) {\n        let didSet = false;\n        if (FromEventObservable.globalTransaction === undefined) {\n            FromEventObservable.globalTransaction = tx;\n            didSet = true;\n        }\n        try {\n            fn();\n        }\n        finally {\n            if (didSet) {\n                FromEventObservable.globalTransaction = undefined;\n            }\n        }\n    }\n    observableFromEvent.batchEventsGlobally = batchEventsGlobally;\n})(observableFromEvent || (observableFromEvent = {}));\nfunction observableSignalFromEvent(debugName, event) {\n    return new FromEventObservableSignal(debugName, event);\n}\nclass FromEventObservableSignal extends _base_js__WEBPACK_IMPORTED_MODULE_2__.BaseObservable {\n    constructor(debugName, event) {\n        super();\n        this.debugName = debugName;\n        this.event = event;\n        this.handleEvent = () => {\n            (0,_base_js__WEBPACK_IMPORTED_MODULE_2__.transaction)((tx) => {\n                for (const o of this.observers) {\n                    tx.updateObserver(o, this);\n                    o.handleChange(this, undefined);\n                }\n            }, () => this.debugName);\n        };\n    }\n    onFirstObserverAdded() {\n        this.subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this.subscription.dispose();\n        this.subscription = undefined;\n    }\n    get() {\n        // NO OP\n    }\n}\nfunction observableSignal(debugNameOrOwner) {\n    if (typeof debugNameOrOwner === 'string') {\n        return new ObservableSignal(debugNameOrOwner);\n    }\n    else {\n        return new ObservableSignal(undefined, debugNameOrOwner);\n    }\n}\nclass ObservableSignal extends _base_js__WEBPACK_IMPORTED_MODULE_2__.BaseObservable {\n    get debugName() {\n        return new _debugName_js__WEBPACK_IMPORTED_MODULE_3__.DebugNameData(this._owner, this._debugName, undefined).getDebugName(this) ?? 'Observable Signal';\n    }\n    toString() {\n        return this.debugName;\n    }\n    constructor(_debugName, _owner) {\n        super();\n        this._debugName = _debugName;\n        this._owner = _owner;\n    }\n    trigger(tx, change) {\n        if (!tx) {\n            (0,_base_js__WEBPACK_IMPORTED_MODULE_2__.transaction)(tx => {\n                this.trigger(tx, change);\n            }, () => `Trigger signal ${this.debugName}`);\n            return;\n        }\n        for (const o of this.observers) {\n            tx.updateObserver(o, this);\n            o.handleChange(this, change);\n        }\n    }\n    get() {\n        // NO OP\n    }\n}\n/**\n * This makes sure the observable is being observed and keeps its cache alive.\n */\nfunction keepObserved(observable) {\n    const o = new KeepAliveObserver(false, undefined);\n    observable.addObserver(o);\n    return (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => {\n        observable.removeObserver(o);\n    });\n}\n(0,_base_js__WEBPACK_IMPORTED_MODULE_2__._setKeepObserved)(keepObserved);\n/**\n * This converts the given observable into an autorun.\n */\nfunction recomputeInitiallyAndOnChange(observable, handleValue) {\n    const o = new KeepAliveObserver(true, handleValue);\n    observable.addObserver(o);\n    if (handleValue) {\n        handleValue(observable.get());\n    }\n    else {\n        observable.reportChanges();\n    }\n    return (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => {\n        observable.removeObserver(o);\n    });\n}\n(0,_base_js__WEBPACK_IMPORTED_MODULE_2__._setRecomputeInitiallyAndOnChange)(recomputeInitiallyAndOnChange);\nclass KeepAliveObserver {\n    constructor(_forceRecompute, _handleValue) {\n        this._forceRecompute = _forceRecompute;\n        this._handleValue = _handleValue;\n        this._counter = 0;\n    }\n    beginUpdate(observable) {\n        this._counter++;\n    }\n    endUpdate(observable) {\n        this._counter--;\n        if (this._counter === 0 && this._forceRecompute) {\n            if (this._handleValue) {\n                this._handleValue(observable.get());\n            }\n            else {\n                observable.reportChanges();\n            }\n        }\n    }\n    handlePossibleChange(observable) {\n        // NO OP\n    }\n    handleChange(observable, change) {\n        // NO OP\n    }\n}\nfunction derivedObservableWithCache(owner, computeFn) {\n    let lastValue = undefined;\n    const observable = (0,_derived_js__WEBPACK_IMPORTED_MODULE_4__.derivedOpts)({ owner, debugReferenceFn: computeFn }, reader => {\n        lastValue = computeFn(reader, lastValue);\n        return lastValue;\n    });\n    return observable;\n}\nfunction derivedObservableWithWritableCache(owner, computeFn) {\n    let lastValue = undefined;\n    const onChange = observableSignal('derivedObservableWithWritableCache');\n    const observable = (0,_derived_js__WEBPACK_IMPORTED_MODULE_4__.derived)(owner, reader => {\n        onChange.read(reader);\n        lastValue = computeFn(reader, lastValue);\n        return lastValue;\n    });\n    return Object.assign(observable, {\n        clearCache: (tx) => {\n            lastValue = undefined;\n            onChange.trigger(tx);\n        },\n        setCache: (newValue, tx) => {\n            lastValue = newValue;\n            onChange.trigger(tx);\n        }\n    });\n}\n/**\n * When the items array changes, referential equal items are not mapped again.\n */\nfunction mapObservableArrayCached(owner, items, map, keySelector) {\n    let m = new ArrayMap(map, keySelector);\n    const self = (0,_derived_js__WEBPACK_IMPORTED_MODULE_4__.derivedOpts)({\n        debugReferenceFn: map,\n        owner,\n        onLastObserverRemoved: () => {\n            m.dispose();\n            m = new ArrayMap(map);\n        }\n    }, (reader) => {\n        m.setItems(items.read(reader));\n        return m.getItems();\n    });\n    return self;\n}\nclass ArrayMap {\n    constructor(_map, _keySelector) {\n        this._map = _map;\n        this._keySelector = _keySelector;\n        this._cache = new Map();\n        this._items = [];\n    }\n    dispose() {\n        this._cache.forEach(entry => entry.store.dispose());\n        this._cache.clear();\n    }\n    setItems(items) {\n        const newItems = [];\n        const itemsToRemove = new Set(this._cache.keys());\n        for (const item of items) {\n            const key = this._keySelector ? this._keySelector(item) : item;\n            let entry = this._cache.get(key);\n            if (!entry) {\n                const store = new _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.DisposableStore();\n                const out = this._map(item, store);\n                entry = { out, store };\n                this._cache.set(key, entry);\n            }\n            else {\n                itemsToRemove.delete(key);\n            }\n            newItems.push(entry.out);\n        }\n        for (const item of itemsToRemove) {\n            const entry = this._cache.get(item);\n            entry.store.dispose();\n            this._cache.delete(item);\n        }\n        this._items = newItems;\n    }\n    getItems() {\n        return this._items;\n    }\n}\nclass ValueWithChangeEventFromObservable {\n    constructor(observable) {\n        this.observable = observable;\n    }\n    get onDidChange() {\n        return _event_js__WEBPACK_IMPORTED_MODULE_0__.Event.fromObservableLight(this.observable);\n    }\n    get value() {\n        return this.observable.get();\n    }\n}\nfunction observableFromValueWithChangeEvent(owner, value) {\n    if (value instanceof ValueWithChangeEventFromObservable) {\n        return value.observable;\n    }\n    return observableFromEvent(owner, value.onDidChange, () => value.value);\n}\n/**\n * Works like a derived.\n * However, if the value is not undefined, it is cached and will not be recomputed anymore.\n * In that case, the derived will unsubscribe from its dependencies.\n*/\nfunction derivedConstOnceDefined(owner, fn) {\n    return derivedObservableWithCache(owner, (reader, lastValue) => lastValue ?? fn(reader));\n}\n\n\n//# sourceURL=webpack://abaplint-playground/./node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils.js?\n}");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services/languageService.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services/languageService.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LanguageService: () => (/* binding */ LanguageService)\n/* harmony export */ });\n/* harmony import */ var _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/event.js */ \"./node_modules/monaco-editor/esm/vs/base/common/event.js\");\n/* harmony import */ var _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/lifecycle.js */ \"./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js\");\n/* harmony import */ var _languagesRegistry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./languagesRegistry.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/services/languagesRegistry.js\");\n/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../base/common/arrays.js */ \"./node_modules/monaco-editor/esm/vs/base/common/arrays.js\");\n/* harmony import */ var _languages_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../languages.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/languages.js\");\n/* harmony import */ var _languages_modesRegistry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../languages/modesRegistry.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/languages/modesRegistry.js\");\n/* harmony import */ var _base_common_observable_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../base/common/observable.js */ \"./node_modules/monaco-editor/esm/vs/base/common/observable.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\nclass LanguageService extends _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.Disposable {\n    static { this.instanceCount = 0; }\n    constructor(warnOnOverwrite = false) {\n        super();\n        this._onDidRequestBasicLanguageFeatures = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter());\n        this.onDidRequestBasicLanguageFeatures = this._onDidRequestBasicLanguageFeatures.event;\n        this._onDidRequestRichLanguageFeatures = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter());\n        this.onDidRequestRichLanguageFeatures = this._onDidRequestRichLanguageFeatures.event;\n        this._onDidChange = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter({ leakWarningThreshold: 200 /* https://github.com/microsoft/vscode/issues/119968 */ }));\n        this.onDidChange = this._onDidChange.event;\n        this._requestedBasicLanguages = new Set();\n        this._requestedRichLanguages = new Set();\n        LanguageService.instanceCount++;\n        this._registry = this._register(new _languagesRegistry_js__WEBPACK_IMPORTED_MODULE_2__.LanguagesRegistry(true, warnOnOverwrite));\n        this.languageIdCodec = this._registry.languageIdCodec;\n        this._register(this._registry.onDidChange(() => this._onDidChange.fire()));\n    }\n    dispose() {\n        LanguageService.instanceCount--;\n        super.dispose();\n    }\n    isRegisteredLanguageId(languageId) {\n        return this._registry.isRegisteredLanguageId(languageId);\n    }\n    getLanguageIdByLanguageName(languageName) {\n        return this._registry.getLanguageIdByLanguageName(languageName);\n    }\n    getLanguageIdByMimeType(mimeType) {\n        return this._registry.getLanguageIdByMimeType(mimeType);\n    }\n    guessLanguageIdByFilepathOrFirstLine(resource, firstLine) {\n        const languageIds = this._registry.guessLanguageIdByFilepathOrFirstLine(resource, firstLine);\n        return (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_3__.firstOrDefault)(languageIds, null);\n    }\n    createById(languageId) {\n        return new LanguageSelection(this.onDidChange, () => {\n            return this._createAndGetLanguageIdentifier(languageId);\n        });\n    }\n    createByFilepathOrFirstLine(resource, firstLine) {\n        return new LanguageSelection(this.onDidChange, () => {\n            const languageId = this.guessLanguageIdByFilepathOrFirstLine(resource, firstLine);\n            return this._createAndGetLanguageIdentifier(languageId);\n        });\n    }\n    _createAndGetLanguageIdentifier(languageId) {\n        if (!languageId || !this.isRegisteredLanguageId(languageId)) {\n            // Fall back to plain text if language is unknown\n            languageId = _languages_modesRegistry_js__WEBPACK_IMPORTED_MODULE_5__.PLAINTEXT_LANGUAGE_ID;\n        }\n        return languageId;\n    }\n    requestBasicLanguageFeatures(languageId) {\n        if (!this._requestedBasicLanguages.has(languageId)) {\n            this._requestedBasicLanguages.add(languageId);\n            this._onDidRequestBasicLanguageFeatures.fire(languageId);\n        }\n    }\n    requestRichLanguageFeatures(languageId) {\n        if (!this._requestedRichLanguages.has(languageId)) {\n            this._requestedRichLanguages.add(languageId);\n            // Ensure basic features are requested\n            this.requestBasicLanguageFeatures(languageId);\n            // Ensure tokenizers are created\n            _languages_js__WEBPACK_IMPORTED_MODULE_4__.TokenizationRegistry.getOrCreate(languageId);\n            this._onDidRequestRichLanguageFeatures.fire(languageId);\n        }\n    }\n}\nclass LanguageSelection {\n    constructor(onDidChangeLanguages, selector) {\n        this._value = (0,_base_common_observable_js__WEBPACK_IMPORTED_MODULE_6__.observableFromEvent)(this, onDidChangeLanguages, () => selector());\n        this.onDidChange = _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__.Event.fromObservable(this._value);\n    }\n    get languageId() {\n        return this._value.get();\n    }\n}\n\n\n//# sourceURL=webpack://abaplint-playground/./node_modules/monaco-editor/esm/vs/editor/common/services/languageService.js?\n}");

/***/ })

}]);